1.6.3 事件化驱动
---------------

&nbsp;

Shadow Widget 的事件化驱动，是用 duals 属性的 setter 机制实现的。纯粹的 setter 回调与事件触发还有些距离，我们附加若干规则，让基于 duals 的赋值、侦听等过程，用起来就像事件驱动的过程。

#### 不重复触发

前面已介绍在 `shouldComponentUpdate` 函数中判断 props 与 state 属性是否有更新，有更新后才会 `render` 刷新。对 duals 赋值也遵守相同规则，**只有新值不恒等于旧值赋值才生效**，否则 duals 属性赋值自动忽略。

某些时候，我们又希望每次赋值都触发动作，即便数据取值与旧值一样也要触发。不妨将该数据包上一层变化着的 ID 值，比如 `[data,ID]`，按如下方式赋值：

``` js
  comp.duals.notifyData = [data, ex.time()];
```

`ex.time()` 得到的是 “由当前时间转换而来的整数”，其值可用来标识界面操作的唯一 ID，这样，每次操作传递 `[data,ex.time()]` 都能触发相应的 setter 函数了。

#### <a name="delay_apply"></a>即时生效与延时生效

Component 的 `render()` 调用是一个特殊过程，因为会更改界面输出，所以 React 对它提供几项特别保护，比如，不能调用 `comp.getHtmlNode()` 取真实 DOM 节点，不能调用  `comp.setState()` 避免尚在变迁中的状态陷于重入。

执行 `this.duals.attr = value` 语句同样也要适应这种风格，setter 调用并不总会立即发生，而是在遵守这个条件的前提下发生：`render()` 调用的入口位置插入对自身 duals 属性赋值的集中处理，集中处理时，给 `this.duals.attr` 赋值才立即生效，即，相应 setter 函数立即被调用，一旦过了集中处理期，对 `this.duals.attr` 赋值只是临时记录，等下一轮 `render()` 才真正去赋值。

所以，**针对 `duals.attr` 赋值具有延时效应**，而且，在双源属性的 setter 函数中，如果有若干 `this.duals.attr = value` 赋值语句，它们将即时生效，因为 setter 被调时当前节点还在上述 “集中处理期”。但是，**setter 函数中若对其它节点的 duals 属性赋值，仍是延时生效**。

概括来讲，`render()` 处理中，针对构件自身的 `duals.attr` 赋值，批次执行，可重入、可递归，但针对其它构件 `duals.attr` 赋值会延时。

调用 `listen()` 侦听某双源属性，当侦听源有变化，系统将自动触发侦听动作，但这种 “触发” 也是 “延时执行”。所谓延时，就是 `setTimeout(callback,0)` 语句，延后 0 秒再调 `callback` 函数。请注意，回调处理与事件处理的本质差别在这儿，事件要遵循特定调度规则，并不立即生效。

#### 事件化驱动

双源属性的 setter 回调，受上述 “不重复触发” 与 “延时生效” 两条规则约束，就从常规 `callback` 函数进化到事件处理机制了。

该事件机制还具备 “一对多” 与 “异步运算同步等待” 能力。“一对多” 是指一个 duals 属性可在多处侦听，形成分叉数据流，[“异步运算同步等待”](#1.7.3.) 解决任务并发与同步的问题，将在后面章节介绍。

总之，Shadow Widget 的事件处理机制，保障了数据单向流动，前后步有时序区隔，数据流可环回，但不陷入递归。

&nbsp;
