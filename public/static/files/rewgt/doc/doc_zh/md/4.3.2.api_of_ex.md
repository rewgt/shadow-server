4.3.2 API函数
------------

&nbsp;

> 只能在可计算表达式中使用的 API
> - [`setVar`](#4.3.2.!set_var)
> - [`evalInfo`](#4.3.2.!eval_info)
> - [`ajax`](#4.3.2.!ajax)
> - [`jsonp`](#4.3.2.!jsonp)
> - [`setChecked`](#4.3.2.!set_checked)

> 从 javascript 函数封装而来的 API
> - [`log`](#4.3.2.!log)
> - [`time`](#4.3.2.!time)
> - [`isFalse`](#4.3.2.!is_false)
> - [`isTrue`](#4.3.2.!is_true)
> - [`parseInt`](#4.3.2.!parse_int)
> - [`parseFloat`](#4.3.2.!parse_float)
> - [`escape`](#4.3.2.!escape)
> - [`unescape`](#4.3.2.!unescape)
> - [`order`](#4.3.2.!order)

> 其它
> - [`update`](#4.3.2.!update)
> - [`tagValue`](#4.3.2.!tag_value)
> - [`tagFired`](#4.3.2.!tag_fired)

&nbsp;

##### <a name="set_var"></a>`setVar(sName,value)`

> 在当前 callspace 设置名为 `sName`，值为 `value` 的变量，本函数既可用创建新变量，也可替换已存在的旧变量。经设置的变量，在可计算表达式中能直接使用。

##### <a name="eval_info"></a>`evalInfo()`

> 用于查询当前可计算表达式的相关信息，返回值为 `[component, attrName, iTimeId]`，其中 `attrName` 是当前正在运算的可计算属性，`component` 是当前可计算属性所在的 R 节点，`iTimeId` 指示当前可计算表达开始计算的时间，是毫秒为单位的整数值。如果查询失败，返回 `undefined`。

##### <a name="ajax"></a>`ajax(config,initValue)`

> 本函数提供 `utils.ajax(config)` 的功能，参数 `config` 的格式与 `utils.ajax(config)` 的参数要求相同，但 `config.success` 与 `config.error` 要求空出来不作定义。参数 `initValue` 用来指定 ajax 调用的缺省结果值，其值在发送请求前就被设到当前可计算属性中（只有属性值尚未设置时才赋 `initValue` 值）。`initValue` 可以缺省，但若指定，要求符合 `{status:'',data:null}` 格式。其中，`status` 指示 ajax 调用的状态结果（如取值 `'success', 'error'` 等），`data` 则保存 ajax 调用的结果。

> `ex.ajax()` 调用能自动识别在哪个 component 的哪个可计算属性（比如 `$ajax`）里发起 ajax 服务，服务调用是异步进行的，获得调用结果时自动按 `{status:status,data:data}` 格式，设到当前可计算属性（比如 `duals.ajax`）。

##### <a name="jsonp"></a>`jsonp(config,initValue)`

> 本函数提供 `utils.jsonp(config)` 的功能，参数 `config` 的格式与 `utils.jsonp(config)` 的参数要求相同，但 `config.callback` 要求空出来不作定义。参数 `initValue` 用来指定 jsonp 调用的缺省结果值，其值在发送请求前就被设到当前可计算属性中（只有属性值尚未设置时才赋 `initValue` 值）。`initValue` 参数可以缺省。

> `ex.jsonp()` 调用能自动识别在哪个 component 的哪个可计算属性（比如 `$jsonp`）里发起 jsonp 服务，服务调用是异步进行的，获得调用结果自动设到当前可计算属性（比如 `duals.jsonp`）。

##### <a name="set_checked"></a>`setChecked(sPath,newOpt)`

> 用于触发选项构件，参数 `sPath` 用来定位选项构件，可以用绝对路径，也可用相对路径（以当前可计算表达式所在的节点为参考点），参数 `newOpt` 可缺省，它用于叠加选项构件的 `duals.popOption` 弹窗选项。

> 调用 `ex.setChecked()` 等效于在界面对选项构件做 “点击选中” 操作。

##### <a name="log"></a>`log(arg, ...)`

> 用于打印输出，相当于对 `console.log` 做封装，使之适合在可计算表达式中使用。可带一个参数 `arg`，也可带多个，各个参数将依次被打印。

##### <a name="time"></a>`time()`

> 取当前时间的整数值，相当于 `(new Date()).valueOf()`。

##### <a name="is_false"></a>`isFalse(value)`

> 用于判断 `value` 转成 boolean 后是否为 `false`，相当于 `!value`。

> 因为 MJI 解释器不支持 “取非”（即 `'!'`）一元操作，导致类似 `!condA == !condB` 的表达式不容易书写，不妨用 `isFalse` 替代，写成 `ex.isFalse(condA) == ex.isFalse(condB)`。

##### <a name="is_true"></a>`isTrue(value)`

> 用于判断 `value` 转成 boolean 后是否为 `true`，相当于 `!!value`。

> 因为 MJI 解释器不支持 “取非”（即 `'!'`）一元操作，导致类似 `!!condA == !!condB` 的表达式不容易书写，不妨用 `isTrue` 替代，写成 `ex.isTrue(condA) == ex.isTrue(condB)`。

##### <a name="parse_int"></a>`parseInt(value)`

> 等效于 javascript 的 `parseInt(value)` 函数。

##### <a name="parse_float"></a>`parseFloat(value)`

> 等效于 javascript 的 `parseFloat(value)` 函数。

##### <a name="escape"></a>`escape(str)`

> 等效于 javascript 代码 `window.escape(str)`。

##### <a name="unescape"></a>`unescape(str)`

> 等效于 javascript 代码 `window.unescape(str)`。

##### <a name="order"></a>`order(data, opt, ...)`

> 对 `data` 数据排序，返回值是排序结果。`data` 要求是 array 类型，其后参数 `opt` 用来指明排序规则，规则可以有 1 项，或者多项。当 `opt` 是 string 类型时表示属性名，将按 `data[N][opt]` 取值排序，`opt` 字串还可以是类似 `segA.segB` 多段格式，此时按 `data[N][segA][segB]` 取值排序，如果 `opt` 是 number 类型，若 `opt` 大于等于 0，表示正序，否则逆序，表达正、逆序的规则项，只能作为最后一个参数传入。number 类型的 `opt` 最多只能传入 1 个，但 string 类型的 `opt` 可以传多个。

> 例如：`ex.order(data,'attr1','attr2.attr3',-1)`，表示按 `data[N].attr1` 排序，如果值相等，再以 `data[N].attr2.attr3` 为准排序，`-1` 表示采用逆向排序。

> 这个 `ex.order()` 正是 `$for` 表达式中排序所调用的函数。

##### <a name="update"></a>`update(data,modifier)`

> 用于浅拷贝数据，参数 `data` 是源数据，要求是 array 或 object 类型，`modifier` 指示如何拷贝，返回值是拷贝结果。本函数就是 React add-on 的 <a target="_blank" href="https://facebook.github.io/react/docs/update.html">update 函数</a>。

##### <a name="tag_value"></a>`tagValue(modifier)`

> 用于给传入参数 `modifier` 追加对首层成员的时间标签设置，返回追加了标签的结果值。比如：`modifier` 为 `{membA:{$set:{attr:value}}}`，调用 `ex.tagValue(modifier)` 后相当于得到如下值：

```
    { membA: {$set: 
      { attr: value,
        time: ex.time()    // this line is added
      }
    } }
```

> 这样，再用这个追加了时间标签的 `modifier` 做浅拷贝，运行 `ex.update(data,modifier)` 后，`data.membA.time` 值也附带着自动更新了。

##### <a name="tag_fired"></a>`tagFired(data,attr, ...)`

> 用于检查 `data` 数据的某个（或某几个）首层成员的时间标签是否为非零，若均为非零则把相关时间标签清零并返回 `true`，否则返回 `false`。`attr` 指明待检查的首层成员名，可检查多个首层成员名，比如 `ex.tagFired(data,'membA','membB')` 将检查 `data.membA.time` 与 `data.membB.time` 是否同时非零，若同时非零，将它们清零并返回 `true` 值，否则不作改变并返回 `false` 值。

> `ex.tagFired()` 与 `ex.tagValue()` 常配合使用，后者设置时间标签为非零值，前查检查时间标签是否为非零。

<div class="rewgt-mdref" path=".rewgt.book_top"></div>

&nbsp;
